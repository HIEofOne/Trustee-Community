'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('../../../dist/base-797ad073.cjs.prod.js');
var client = require('../../../dist/client-a6e61429.cjs.prod.js');
require('eventemitter3');
require('../../../dist/chains-f7bb3211.cjs.prod.js');
require('../../../dist/rpcs-1fd0a12f.cjs.prod.js');
require('zustand/vanilla');
require('zustand/middleware');
require('ethers');
require('ethers/lib/utils');

var _provider = /*#__PURE__*/new WeakMap();

var _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();

var _getReady = /*#__PURE__*/new WeakSet();

var _findProvider = /*#__PURE__*/new WeakSet();

class MetaMaskConnector extends client.InjectedConnector {
  constructor() {
    let {
      chains,
      options: options_
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const options = {
      name: 'MetaMask',
      shimDisconnect: true,
      shimChainChangedDisconnect: true,
      ...options_
    };
    super({
      chains,
      options
    });

    base._classPrivateMethodInitSpec(this, _findProvider);

    base._classPrivateMethodInitSpec(this, _getReady);

    base._defineProperty(this, "id", 'metaMask');

    base._defineProperty(this, "ready", typeof window != 'undefined' && !!base._classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));

    base._classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });

    base._classPrivateFieldInitSpec(this, _UNSTABLE_shimOnConnectSelectAccount, {
      writable: true,
      value: void 0
    });

    base._classPrivateFieldSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);
  }

  async connect() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    try {
      var _this$options, _getClient$storage, _this$options2, _getClient$storage2;

      const provider = await this.getProvider();
      if (!provider) throw new base.ConnectorNotFoundError();

      if (provider.on) {
        provider.on('accountsChanged', this.onAccountsChanged);
        provider.on('chainChanged', this.onChainChanged);
        provider.on('disconnect', this.onDisconnect);
      }

      this.emit('message', {
        type: 'connecting'
      }); // Attempt to show wallet select prompt with `wallet_requestPermissions` when
      // `shimDisconnect` is active and account is in disconnected state (flag in storage)

      if (base._classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && (_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimDisconnect && !((_getClient$storage = client.getClient().storage) !== null && _getClient$storage !== void 0 && _getClient$storage.getItem(client.shimDisconnectKey))) {
        const accounts = await provider.request({
          method: 'eth_accounts'
        }).catch(() => []);
        const isConnected = !!accounts[0];
        if (isConnected) await provider.request({
          method: 'wallet_requestPermissions',
          params: [{
            eth_accounts: {}
          }]
        });
      }

      const account = await this.getAccount(); // Switch to chain if provided

      let id = await this.getChainId();
      let unsupported = this.isChainUnsupported(id);

      if (chainId && id !== chainId) {
        const chain = await this.switchChain(chainId);
        id = chain.id;
        unsupported = this.isChainUnsupported(id);
      }

      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage2 = client.getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(client.shimDisconnectKey, true);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider
      };
    } catch (error) {
      if (this.isUserRejectedRequestError(error)) throw new base.UserRejectedRequestError(error);
      if (error.code === -32002) throw new base.ResourceUnavailableError(error);
      throw error;
    }
  }

  async getProvider() {
    if (typeof window !== 'undefined') {
      // TODO: Fallback to `ethereum#initialized` event for async injection
      // https://github.com/MetaMask/detect-provider#synchronous-and-asynchronous-injection=
      base._classPrivateFieldSet(this, _provider, base._classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));
    }

    return base._classPrivateFieldGet(this, _provider);
  }

}

function _getReady2(ethereum) {
  const isMetaMask = !!(ethereum !== null && ethereum !== void 0 && ethereum.isMetaMask);
  if (!isMetaMask) return; // Brave tries to make itself look like MetaMask
  // Could also try RPC `web3_clientVersion` if following is unreliable

  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) return;
  if (ethereum.isTokenPocket) return;
  if (ethereum.isTokenary) return;
  return ethereum;
}

function _findProvider2(ethereum) {
  if (ethereum !== null && ethereum !== void 0 && ethereum.providers) return ethereum.providers.find(base._classPrivateMethodGet(this, _getReady, _getReady2));
  return base._classPrivateMethodGet(this, _getReady, _getReady2).call(this, ethereum);
}

exports.MetaMaskConnector = MetaMaskConnector;
